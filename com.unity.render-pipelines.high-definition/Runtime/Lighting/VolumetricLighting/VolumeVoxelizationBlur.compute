//--------------------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------------------

// #pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel VolumeVoxelizationBruteforceMQ VolumeVoxelization=VolumeVoxelizationBruteforceMQ LIGHTLOOP_SINGLE_PASS VL_PRESET_MQ
#pragma kernel VolumeVoxelizationTiledMQ      VolumeVoxelization=VolumeVoxelizationTiledMQ      LIGHTLOOP_TILE_PASS   VL_PRESET_MQ
#pragma kernel VolumeVoxelizationBruteforceHQ VolumeVoxelization=VolumeVoxelizationBruteforceHQ LIGHTLOOP_SINGLE_PASS VL_PRESET_HQ
#pragma kernel VolumeVoxelizationTiledHQ      VolumeVoxelization=VolumeVoxelizationTiledHQ      LIGHTLOOP_TILE_PASS   VL_PRESET_HQ

#ifdef LIGHTLOOP_TILE_PASS
    #define USE_BIG_TILE_LIGHTLIST
#endif

#ifdef VL_PRESET_MQ
    // E.g. for 1080p: (1920/8)x(1080/8)x(64)  =  2,073,600 voxels
    // Same texel count as in a 1080p frame buffer.
    #define VBUFFER_TILE_SIZE 8
#endif
#ifdef VL_PRESET_HQ
    // E.g. for 1080p: (1920/4)x(1080/4)x(128) = 16,588,800 voxels
    // Double the texel count of a 4K frame buffer!
    #define VBUFFER_TILE_SIZE 4
#endif

#define GROUP_SIZE_1D     8
#define SOFT_VOXELIZATION 1 // Hack which attempts to determine partial coverage of the voxel

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/VolumeRendering.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Core/Utilities/GeometryUtils.cs.hlsl"

// We need to include this "for reasons"...
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
#define SHADERPASS SHADERPASS_VOLUME_VOXELIZATION

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricLighting.cs.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightEvaluation.hlsl"


//--------------------------------------------------------------------------------------------------
// Inputs & outputs
//--------------------------------------------------------------------------------------------------

RW_TEXTURE3D(float4, _VBufferDensity); // RGB = sqrt(scattering), A = sqrt(extinction)
RW_TEXTURE3D(float4, _VBufferDensityBlur);

int _VBufferDensityBlurAxis;

[numthreads(GROUP_SIZE_1D, GROUP_SIZE_1D, 1)]
void VolumeVoxelization(uint2 groupId       : SV_GroupID,
                        uint2 groupThreadId : SV_GroupThreadID)
{
    // Perform compile-time checks.
    if (!IsPower2(VBUFFER_TILE_SIZE) || !IsPower2(TILE_SIZE_BIG_TILE)) return;

    uint2 groupOffset = groupId * GROUP_SIZE_1D;
    uint2 voxelCoord  = groupOffset + groupThreadId;

    float2 centerCoord = voxelCoord + float2(0.5, 0.5);

    const int filterRadiusPixels = 5;
    const float filterSharpness = -1.0f / ((float)filterRadiusPixels * (float)filterRadiusPixels * 2.0f / 9.0f);
    for (uint slice = 0; slice < _VBufferSliceCount; slice++)
    {
        uint3 voxelCoord = uint3(centerCoord, slice);

        if (_VBufferDensityBlurAxis == 3)
        {
            // Axis 3 == All blurring has taken place, simply blit from _VBufferDensityBlur back to original _VBufferDensity buffer.
            _VBufferDensity[voxelCoord] = _VBufferDensityBlur[voxelCoord];
            continue;
        }

        float4 accumulatedResult = 0.0f;
        float accumulatedWeight = 0.0f;

        // Filter weights are low at edge of window. Do not waste samples at this threshold.
        for (int i = -filterRadiusPixels + 1; i <= (filterRadiusPixels - 1); ++i)
        {
            int3 sampleCoord = (int3)voxelCoord;
            switch (_VBufferDensityBlurAxis)
            {
                case 0: sampleCoord.x += i; break;
                case 1: sampleCoord.y += i; break;
                case 2: sampleCoord.z += i; break;
            }

            if (
                (min(min(sampleCoord.x, sampleCoord.y), sampleCoord.z) < 0)
                || (sampleCoord.z >= (int)_VBufferSliceCount)
                // || (sampleCoord.x >= ScreenSize)
            )
            {
                continue;
            }

            float sampleDistance2 = (float)i * (float)i;
            float sampleWeight = exp(filterSharpness * sampleDistance2);
            accumulatedWeight += sampleWeight;
            switch (_VBufferDensityBlurAxis)
            {
                case 0: accumulatedResult += _VBufferDensity[(uint3)sampleCoord] * sampleWeight; break;
                case 1: accumulatedResult += _VBufferDensityBlur[(uint3)sampleCoord] * sampleWeight; break;
                case 2: accumulatedResult += _VBufferDensity[(uint3)sampleCoord] * sampleWeight; break;
            }
        }

        float accumulatedWeightInverse = (accumulatedWeight != 0.0f) ? (1.0f / accumulatedWeight) : 0.0f;
        accumulatedResult *= accumulatedWeightInverse;

        switch (_VBufferDensityBlurAxis)
        {
            case 0: _VBufferDensityBlur[voxelCoord] = accumulatedResult; break;
            case 1: _VBufferDensity[voxelCoord] = accumulatedResult; break;
            case 2: _VBufferDensityBlur[voxelCoord] = accumulatedResult; break;
        }
    }
}
